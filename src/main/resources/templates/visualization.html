<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>All-in-One Visualizer Lab</title>

<link rel="stylesheet" href="/css/style.css">

<style>
.lab-grid{display:grid;grid-template-columns:1fr;gap:40px;}
.mini-visualizer{min-height:160px;padding:20px;margin-top:15px;}
canvas{background:transparent;border:1px dashed #cbd5e1;}
</style>
</head>

<body>

<div class="navbar">
<h2>Data Structures Lab</h2>
<a href="/topics">Back to Topics</a>
</div>

<div class="container">

<!-- ================= BST ================= -->
<div class="card">
<h2>Binary Search Tree</h2>

<div class="controls">
<input id="treeValue" type="number" placeholder="Value">
<button onclick="treeInsert()">Insert</button>
<button onclick="treeSearch()">Search</button>
<button class="danger" onclick="treeClear()">Clear</button>
</div>

<p id="treeMsg">Ready.</p>

<canvas id="treeCanvas" width="800" height="300"></canvas>
</div>

<!-- ================= GRAPH ================= -->
<div class="card">
<h2>Graph Visualizer</h2>

<div class="controls">
<input id="graphU" placeholder="Node A">
<input id="graphV" placeholder="Node B">
<button onclick="graphAddEdge()">Connect</button>

<input id="graphStart" placeholder="Start">
<button onclick="graphBFS()">BFS</button>

<button class="danger" onclick="graphClear()">Clear</button>
</div>

<p id="graphMsg">Click canvas to create nodes.</p>

<canvas id="graphCanvas" width="800" height="300"></canvas>
</div>

</div>

<script>
document.addEventListener("DOMContentLoaded", () => {

/* =====================================================
   SAFE CANVAS INITIALIZER (Fixes Render deployment bug)
=====================================================*/
function waitForCanvas(id, callback){
    const check=()=>{
        const el=document.getElementById(id);
        if(el && el.offsetWidth>0) callback(el);
        else requestAnimationFrame(check);
    };
    check();
}

/* =====================================================
                    BINARY SEARCH TREE
=====================================================*/

class TreeNode{
    constructor(v){
        this.val=v;
        this.left=null;
        this.right=null;
        this.x=0;
        this.y=0;
    }
}

let treeRoot=new TreeNode(50);
treeRoot.left=new TreeNode(30);
treeRoot.right=new TreeNode(70);

let treeCanvas, tCtx;

waitForCanvas("treeCanvas",(canvas)=>{
    treeCanvas=canvas;
    tCtx=treeCanvas.getContext("2d");
    renderTree();
});

function calcPos(node,x,y,offset){
    if(!node) return;
    node.x=x; node.y=y;
    calcPos(node.left,x-offset,y+60,offset/2);
    calcPos(node.right,x+offset,y+60,offset/2);
}

function drawEdges(node){
    if(!node) return;
    if(node.left){
        tCtx.beginPath();
        tCtx.moveTo(node.x,node.y);
        tCtx.lineTo(node.left.x,node.left.y);
        tCtx.stroke();
        drawEdges(node.left);
    }
    if(node.right){
        tCtx.beginPath();
        tCtx.moveTo(node.x,node.y);
        tCtx.lineTo(node.right.x,node.right.y);
        tCtx.stroke();
        drawEdges(node.right);
    }
}

function drawNodes(node){
    if(!node) return;

    tCtx.beginPath();
    tCtx.arc(node.x,node.y,18,0,Math.PI*2);
    tCtx.fillStyle="white";
    tCtx.fill();
    tCtx.stroke();

    tCtx.fillStyle="black";
    tCtx.textAlign="center";
    tCtx.textBaseline="middle";
    tCtx.fillText(node.val,node.x,node.y);

    drawNodes(node.left);
    drawNodes(node.right);
}

function renderTree(){
    if(!tCtx) return;
    tCtx.clearRect(0,0,treeCanvas.width,treeCanvas.height);
    calcPos(treeRoot,treeCanvas.width/2,40,treeCanvas.width/4);
    drawEdges(treeRoot);
    drawNodes(treeRoot);
}

window.treeInsert=function(){
    const v=parseInt(document.getElementById("treeValue").value);
    if(isNaN(v)) return;

    if(!treeRoot){ treeRoot=new TreeNode(v); renderTree(); return; }

    let cur=treeRoot;
    while(true){
        if(v<cur.val){
            if(!cur.left){cur.left=new TreeNode(v);break;}
            cur=cur.left;
        }else{
            if(!cur.right){cur.right=new TreeNode(v);break;}
            cur=cur.right;
        }
    }
    renderTree();
}

window.treeSearch=function(){
    alert("Search visualization simplified in stable version.");
}

window.treeClear=function(){
    treeRoot=null;
    renderTree();
}

/* =====================================================
                        GRAPH
=====================================================*/

let gCanvas,gCtx;
let nodes=[],edges=[],adj=new Map();
let nextId=0;

waitForCanvas("graphCanvas",(canvas)=>{
    gCanvas=canvas;
    gCtx=gCanvas.getContext("2d");

    gCanvas.addEventListener("click",graphCanvasClick);
    renderGraph();
});

function graphCanvasClick(e){
    const rect=gCanvas.getBoundingClientRect();
    const x=e.clientX-rect.left;
    const y=e.clientY-rect.top;

    nodes.push({id:nextId,x,y});
    adj.set(nextId,[]);
    nextId++;

    renderGraph();
}

window.graphAddEdge=function(){
    const u=parseInt(graphU.value);
    const v=parseInt(graphV.value);
    if(!adj.has(u)||!adj.has(v)) return;

    edges.push({u,v});
    adj.get(u).push(v);
    adj.get(v).push(u);
    renderGraph();
}

function renderGraph(){
    if(!gCtx) return;
    gCtx.clearRect(0,0,gCanvas.width,gCanvas.height);

    gCtx.strokeStyle="#94a3b8";
    edges.forEach(e=>{
        const a=nodes.find(n=>n.id===e.u);
        const b=nodes.find(n=>n.id===e.v);
        gCtx.beginPath();
        gCtx.moveTo(a.x,a.y);
        gCtx.lineTo(b.x,b.y);
        gCtx.stroke();
    });

    nodes.forEach(n=>{
        gCtx.beginPath();
        gCtx.arc(n.x,n.y,18,0,Math.PI*2);
        gCtx.fillStyle="white";
        gCtx.fill();
        gCtx.stroke();
        gCtx.fillStyle="black";
        gCtx.fillText(n.id,n.x,n.y);
    });
}

window.graphBFS=function(){
    alert("BFS animation simplified in stable version.");
}

window.graphClear=function(){
    nodes=[];
    edges=[];
    adj.clear();
    nextId=0;
    renderGraph();
}

});
</script>

</body>
</html>